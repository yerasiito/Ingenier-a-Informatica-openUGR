# -*- coding: utf-8 -*-
"""P0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hQJoAebViaAXKq5-clsj4SeEvxyTUuPZ

# Aprendizaje Automático - Práctica 0 - Introducción a Python, Matplotlib y NumPy

#### Bonus: 5 puntos (1 por ejercicio)

#### Fecha límite de entrega: 12 de Marzo a las 23:59

#### Entrega a través de https://pradogrado2223.ugr.es/

### Nombre completo: <mark>Yeray López Ramírez</mark>



---

Este trabajo, cuya puntuación máxima será de 5 puntos (1 punto por cada uno de los cinco ejercicios), pretende servir como práctica y refuerzo de los conocimientos adquiridos en las primeras
sesiones prácticas, en donde se han introducido los principios de Python, Matplotlib y NumPy.

Límite de entrega: **12 de Marzo de 2023 a las 23:59 (PRADO)**

**Materiales a entregar**: única y exclusivamente este Notebook de Colab (fichero .ipynb). No es necesario entregar ninguna memoria externa, pero el código debe estar bien comentado, y todas las decisiones tomadas y el trabajo desarrollado deben documentarse suficientemente en celdas de texto.

**Nota relativa a la entrega**: la entrega en PRADO está configurada para permitir sucesivas entregas de la práctica. Desde este punto de vista, se recomienda subir versiones de la práctica a medida que se van realizando los distintos ejercicios propuestos, y no dejarlo todo para el final, dado que es altamente improbable que se extienda la fecha de entrega.  

**Nota relativa a la realización de los ejercicios**: se parte de la premisa de que estos ejercicios no son particularmente difíciles, y pretenden evaluar el dominio que posee el/la alumno/a a la hora de manejar Python, en general, y matplotlib y NumPy en particular. En este sentido, el objetivo no es proporcionar *más o menos* las mismas salidas que se muestran en las celdas de texto de este cuaderno, sino exactamente las mismas (mismos colores, mismos marcadores, mismas etiquetas, mismos estilos, etc.). Es decir, se recomienda ser lo más fiel posible a la salida esperada para cada ejercicio.



---
"""

# Importamos paquetes necesarios.
import numpy as np
from sklearn import datasets
import matplotlib.pyplot as plt

# Definimos las fuentes por defecto de las gráficas
plt.rc('font', size=10)          # fuente general
plt.rc('axes', titlesize=12)     # título
plt.rc('axes', labelsize=10)     # ejes x,y

"""## Ejercicio 1: lectura y visualización de datos (Iris Flower)

*   Leer la base de datos de Iris que hay en scikit-learn. Véase https://scikit-learn.org/stable/datasets/toy_dataset.html. El  conjunto de datos de flor Iris (https://en.wikipedia.org/wiki/Iris_flower_data_set), introducido por Ronald Fisher en 1936, es clásico en aprendizaje automático.
*   Obtener las características (datos de entrada $X$) y la clase ($y$).
*   Quedarse con las características segunda y cuarta. Recuérdese que en Python los índices comienzan en $0$.
*   Visualizar con un Scatter Plot los datos, coloreando cada clase con un color diferente e indicando con una leyenda la clase a la que corresponde cada color. Más concretamente, el resultado debe ser exactamente el que se muestra en la celda de resultados que se incluye más abajo. Esta es la única salida que proporciona este ejercicio. No se debe mostrar ninguna otra información en la celda de resultados.

**Explicación del código**

Seguimos los pasos tal cual nos dicen los comentarios

1.   Usamos la librería de **scikit-learn** para obtener el dataset de las flores
2.   En un bucle `for` obtenemos los vectores de caracteristicas 1 y 3 (`a[1]`, `a[3]`) y el tipo de flor(`b`). Guardar el tipo de flor nos vendrá de lujo para el ejercicio 3.
3.   Separamos cada vector de caracteristicas según el tipo de flor
4.   Una vez obtenidos los vectores de características de *setosa*, *versicolor* y *virginica*, los imprimimos con scatter.
"""

# Leemos el dataset
iris = datasets.load_iris()
# Caracteristicas a mantener
caracteristicas = []
for (a,b) in zip(iris.data, iris.target):
  caracteristicas.append([a[1],a[3], b])

# Separamos los datos según su clase
setosa = []
versicolor = []
virginica = []
for x in caracteristicas:
  if(x[2] == 0):
    setosa.append([ x[0], x[1], x[2]])
  elif (x[2] == 1):
    versicolor.append([ x[0], x[1],x[2]])
  elif (x[2] == 2):
    virginica.append([ x[0], x[1], x[2]])

# Visualizamos los datos con un Scatter plot
# https://matplotlib.org/stable/gallery/lines_bars_and_markers/scatter_with_legend.html
# https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html
fig, ax = plt.subplots()
for seto,ver,vir in zip(setosa,versicolor, virginica):
    ax.scatter(seto[0], seto[1], c='red', marker = "*")
    ax.scatter(ver[0], ver[1], c='green', marker = "*")
    ax.scatter(vir[0], vir[1], c='blue', marker = "*")

ax.set(xlabel='sepal width (cm)', ylabel='petal width (cm)')
ax.legend(("setosa","versicolor","virginica"), loc = "upper right")
ax.grid(False)

plt.show()

"""## Ejercicio 2: lectura y visualización de datos (Breast Cancer)

*   Leer la también clásica base de datos de Breast Cancer (introducida en los años 90) que hay en scikit-learn. Véase https://scikit-learn.org/stable/datasets/toy_dataset.html y https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_breast_cancer.html#sklearn.datasets.load_breast_cancer.
*   Obtener las características (datos de entrada $X$) y la clase ($y$).
*   Quedarse con las características denominadas 'mean area' y 'mean texture'. Para identificarlas el alumno debe explorar el conjunto de datos y ver qué índices corresponden a dichas características.  
*   Visualizar con un Scatter Plot los datos, coloreando cada clase con un color diferente e indicando con una leyenda la clase a la que corresponde cada color. El resultado debe ser el que se muestra en la celda de resultados que se incluye más abajo.

**Explicación del código**

Procedemos como en el primer ejercicio.

1.   Obtenemos el nuevo dataset de cáncer de mama
2.   Obtenemos las características: 1 correspondiente a la textura y 3 correspondiente al área.
3.   Usamos la función `split` para separar los vectores de textura y área según el tipo de dato (*benigno* o *maligno*).
4.   Visualizamos los datos con scatter. Usamos zip para iterar sobre los 2 vectores
"""

# Leemos el dataset
dtset = datasets.load_breast_cancer()

# Caracteristicas a mantener
caracteristicas = np.array(dtset.data)

texture = caracteristicas[:,1]
area = caracteristicas[:,3]

# Separamos los datos según su clase
def split(arr, cond):
  return [arr[cond], arr[~cond]]

texMalBen = split(texture, dtset.target == 0) #Divide las texturas en maligno(0) y benigno(1)
areaMalBen = split(area, dtset.target == 0) #Divide las areas en maligno(0) y benigno(1)

# Visualizamos los datos con un Scatter plot
fig, ax = plt.subplots(figsize=(12, 5))
for mal,beg in zip(texMalBen,areaMalBen):
    A = ax.scatter(areaMalBen[0], texMalBen[0],  c='red', marker = "o")
    B = ax.scatter(areaMalBen[1], texMalBen[1], c='green', marker = "o")

ax.set(xlabel='mean area', ylabel='mean texture')
ax.legend((A,B), ("malignant","benign"))
ax.grid(False)

plt.show()

"""* Se debe mostrar también, tal y como se muestra en la celda de resultados, un histograma con la frecuencia de ejemplos de cada clase. También se debe imprimir el número de ejemplos por clase, formateado de la forma que se indica más abajo.

**Explicación del código**

1.   Contamos el numero de datos de cada tipo de cancer con la función `count_nonzero` dentro del dataset y lo metemos en el vector freq.
2.   Usamos bar para dibujar el gráfico de barras.

Para el print usamos `f` de format para imprimir datos entre el texto.
"""

freqMalign = np.count_nonzero(dtset.target == 0)
freqBenign = np.count_nonzero(dtset.target == 1)

clases = dtset.target_names
freq = [freqMalign, freqBenign]

fig, ax = plt.subplots(figsize=(8, 5))
ax.bar(clases, freq, color='tab:blue')
ax.set_title('Numero de ejemplos por clase')

plt.grid(False)
plt.show()

print(f"La clase \"{dtset.target_names[0]}\" tiene {freqMalign} ejemplos")
print(f"La clase \"{dtset.target_names[1]}\" tiene {freqBenign} ejemplos")

"""* Se debe visualizar también, de la forma en que se muestra más abajo, el diagnóstico resultante en función del 'mean radius'. Junto con ello, se deben imprimir los valores máximo y mínimo para cada una de las dos clases

**Explicación del código**

1.   Guardamos el radio que corresponde a la característica 0.
2.   Volvemos a llamar a la función `split` definida anteriormente para separar el vector según la clase de cáncer.
3.   Usamos scatter para visualizar la gráfica
4.   Finalmente, usamos `argmin` y `argmax` de la libreria numpy para calcular los valores de radio mínimo y máximos de cada clase de tumor.
"""

#Guardamos el radio
radio = caracteristicas[:,0]
# Separamos los datos según su clase
radMalBen = split(radio, dtset.target == 0) #Divide las texturas en maligno(0) y benigno(1)
# Visualizamos los datos con un Scatter plot

fig, ax = plt.subplots(figsize=(3.5, 5.5))

x = np.ones(radMalBen[0].shape[0])*0 #Izquierda
ax.scatter(x, radMalBen[0] , color="red", s=50) #Datos malignos
x = np.ones(radMalBen[1].shape[0])*1 #Derecha
ax.scatter(x, radMalBen[1], color="green", s=50) #Datos benignos

ax.set_title('mean radius vs diagnosis')
ax.set(xlabel='diagnosis', ylabel='mean radius')
ax.legend(("malignant","benign"),  loc="upper right")
plt.show()

print(f"La clase \"{dtset.target_names[0]}\" para la variable \"{dtset.feature_names[0]}\" \
presenta unos valores entre {radMalBen[0][radMalBen[0].argmin()]} y {radMalBen[0][radMalBen[0].argmax()]} ")

print(f"La clase \"{dtset.target_names[1]}\" para la variable \"{dtset.feature_names[0]}\" \
presenta unos valores entre {radMalBen[1][radMalBen[1].argmin()]} y {radMalBen[1][radMalBen[1].argmax()]} ")

"""## Ejercicio 3: separación balanceada de conjuntos de entrenamiento y test

*   Partir de los datos de Iris (empleados en el Ejercicio 1), y separar en training (80\% de los datos) y test (20\%) aleatoriamente, conservando la proporción de elementos en cada clase tanto en training como en test. Con esto se pretende evitar que haya clases infra-representadas en entrenamiento o test. Con "aleatoriamente" nos referimos a que no sería válido escoger como conjunto de entrenamiento el 80\% inicial de ejemplos de cada clase y como conjunto de test el 20\% final. Es decir, al principio, los ejemplos pertenecientes a cada clase deben desordenarse con respecto al orden original. En la implementación de este ejercicio no se pueden emplear funciones como $train\_test\_split$ de scikit-learn o similares.
*   Se debe imprimir el número resultante de ejemplos de cada clase, tanto en entrenamiento como en test, así como las clases de cada uno de los ejemplos de entrenamiento y test. En la celda de resultados que se incluye a continuación se muestra el tipo de salida que se espera obtener.

**Explicación del código**

Usamos permutation cuando queremos mezclar los datos sin modificar el original como es el caso de los vectores de flores del ejercicio 1.

Luego seleccionamos los 40 primeros como train y los ultimos 10 como test (los hemos mezclado previamente). Hacemos esto para cada vector de flor randomizado.

Al final concatenamos respectivamente los vectores y usamos shuffle para modificar los indices.

¿Recuerdas que guardamos el tipo de flor en el ejercicio 1? Pues al final usamos ese dato para imprimir los tipos del vector de train y test.
"""

np.random.seed(0)

randSetosa = np.random.permutation(setosa)

print("--- Clase setosa ---" )
print(f"Ejemplos train: {len(randSetosa[0:40])}") # Se deberia de meter en un vector trainSetosa
print(f"Ejemplos test: {len(randSetosa[40:50])}") # Se deberia de meter en un vector testSetosa

randVersicolor = np.random.permutation(versicolor)

print("--- Clase versicolor ---" )
print(f"Ejemplos train: {len(randVersicolor[0:40])}")
print(f"Ejemplos test: {len(randVersicolor[40:50])}")

randVirginica = np.random.permutation(virginica)

print("--- Clase virginica ---" )
print(f"Ejemplos train: {len(randVirginica[0:40])}")
print(f"Ejemplos test: {len(randVirginica[40:50])}")

train = np.array([])
train = np.concatenate([randSetosa[0:40], randVersicolor[0:40], randVirginica[0:40]])
test = np.concatenate([randSetosa[40:50], randVersicolor[40:50], randVirginica[40:50]])

np.random.shuffle(train)
np.random.shuffle(test)

print(f"Clase de los ejemplos de entrenamiento: \n{train[:,2]}")
print(f"Clase de los ejemplos de test: \n{test[:,2]}")

"""## Ejercicio 4: visualización de funciones 2D

*   Obtener 150 valores equiespaciados entre 0 y 4$\pi$
*   Obtener el valor de las siguientes funciones  para los 150 valores anteriormente calculados.

$f_1(x)= 10^{-5}\cdot\sinh(x) + 0.5\cdot\arctan(x)$

$f_2(x)= \cos(x) - 2\cdot\sin(x)$

$f_3(x)= \tanh(5\cdot\sin(x) + 3\cdot\cos(x))$

*   Visualizar las tres curvas simultáneamente en el mismo plot (con líneas discontinuas en rojo, azul y verde) e incluir la leyenda correspondiente. Más concretamente, el resultado debe ser el que se muestra en la siguiente celda de resultados. Esta es la única salida que proporciona este ejercicio. No se debe mostrar ninguna otra información.

**Explicacion del código**

Definimos las funciones que queremos calcular: $f_1$,$f_2$ y $f_3$

Obtenemos los valores de x con la función `arange` de numpy. Hay que tener cuidado ya que el rango final no se incluye, por eso sumamos `step`.

Evaluamos los valores de $y$ de cada función con los valores de $x$ previamente calculados.

Finalmente graficamos los valores de x e y1,y2,y3 con plot. Ajustamos la gráfica para que se parezca a la original (`figsize`,`linewidth`, `labelsize`)
"""

def f1(x):
  return (10 ** -5 * np.sinh(x) + 0.5 * np.arctan(x))

def f2(x):
  return np.cos(x) - 2*np.sin(x)

def f3(x):
  return np.tanh(5*np.sin(x) + 3*np.cos(x))

# Obtener 150 valores equiespaciados entre 0 y 4$\pi$
end = 4*np.pi
step = 4*np.pi/150.0
x = np.array(np.arange(0, end + step, step))

# Obtener el valor de las funciones indicadas para los 150 valores anteriormente calculados.
y1 = f1(x)
y2 = f2(x)
y3 = f3(x)

#Visualizar las tres curvas simultáneamente en el mismo plot (con líneas discontinuas en rojo, azul y verde).
fig, ax = plt.subplots(figsize=(14, 7))

ax.plot(x, y1, color = "red", label = "$f_1(x) = 10^{-5} $· sinh$(x) + 0.5 · $arctan$(x))$",linestyle='dashed')
ax.plot(x, y2, color = "blue", label = "$f_2(x) = $cos$(x) - 2·$sin$(x)$", linestyle='dashed')
ax.plot(x, y3, color = "green", label = "$f_3(x) = $tanh$(5·$sin$(x) + 3·$cos$(x))$", linestyle='dashed')

ax.legend(loc = "upper left", fontsize=12)
ax.grid(linewidth=0.2)

plt.rc('lines', linewidth=1.5)
plt.rc('xtick', labelsize=10)
plt.rc('ytick', labelsize=10)

plt.show()

"""## Ejercicio 5: visualización de funciones 3D

*   Mostrar dos funciones 3D dentro de la misma figura. Las funciones a mostrar son las siguientes:

$f_1(x,y) =  10 - 2\cdot|x+y| + 2\cdot|y-x|$

$f_2(x,y) =  10 \cdot sin(\sqrt{x^2+y^2})$

*   Como se indicaba, ambas funciones deben mostrarse dentro de la misma figura/ventana como *surface plots*. Más concretamente, el resultado debe ser exactamente el que se muestra en la siguiente celda de resultados (tanto a nivel de título de las gráficas, como de rango de valores en los ejes y colores empleados). Esta es la única salida que proporciona este ejercicio. No se debe mostrar ninguna otra información. El siguiente enlace puede servir de ayuda y referencia a la hora de realizar este ejercicio: https://matplotlib.org/stable/gallery/mplot3d/subplot3d.html. De cara a mostrar ecuaciones matemáticas en figuras de Matplotlib usando LaTeX la siguiente referencia puede ser de utilidad: https://matplotlib.org/stable/gallery/text_labels_and_annotations/tex_demo.html.

La función *meshgrid* puede ser de gran utilidad en este ejercicio. Véanse https://interactivechaos.com/es/manual/tutorial-de-numpy/la-funcion-meshgrid
y https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html

**Explicación del código**

Para cada gráfica hacemos lo siguiente:
1.   Configuramos ax para dibujar 2 graficas una al lado de otra (fila, columna, posición). Además de indicar que es una proyección 3d
2.   Al igual que en el anterior ejercicio, generamos los datos con arange teniendo en cuenta el último valor (por eso sumamos step)
3.   No olvidemos que estamos en 3d, hay que generar una matriz con los valores de x e y
4.   Generamos los valores de z con los generados en x e y, evaluándolos con la funciones definidas al principio (f1,f2)
5.   Dibujamos la figura con plot_surface indicando los valores a usar, los "pasos" de dibujado (row de rstride y col de cstride), indicamos el patrón de color coolwarm o viridis y activamos el antialiasing para ver mejor las figuras.
"""

def f1(x, y):
    return 10 - 2 * abs(x+y) + 2 * abs(y-x)
def f2(x,y):
    return 10*np.sin(np.sqrt(x**2+y**2))

fig = plt.figure(figsize=(30, 13))


# =============
# Primera gráfica
# =============
# Configuramos los ejes de la primera gráfica
ax = fig.add_subplot(1, 2, 1, projection='3d') #Num fila, num columna, posicion

range = 6
step = 0.4

x = np.arange(-range, range + step, step)
y = np.arange(-range, range + step, step)
x, y = np.meshgrid(x, y)

z = f1(x,y)
surf1 = ax.plot_surface(x,y,z, rstride=1, cstride=1, cmap=plt.cm.coolwarm,
                        antialiased=True)

ax.set_title("$f_1(x,y) = 10 - 2 · |x+y| + 2 · |y-x|$", fontsize=20)

# ==============
# Segunda gráfica
# ==============
ax = fig.add_subplot(1, 2, 2, projection='3d') #Num fila, num columna, posicion

range = 2
step = 0.05

x = np.arange(-range, range + step, step)
y = np.arange(-range, range + step, step)
x, y = np.meshgrid(x, y)

z = f2(x,y)

surf2 = ax.plot_surface(x,y,z, rstride=1, cstride=1, cmap=plt.cm.viridis,
                        antialiased=True)

ax.set_title("$f_2(x,y) = 10·sin(\sqrt{x^2+y^2})$", fontsize=20)

plt.show()

#si da error latex
#!apt install texlive-fonts-recommended texlive-fonts-extra cm-super dvipng

"""De cara a visualizar gráficos interactivos en Colab (es decir, que os permitan ampliar, mover o desplazaros por un gráfico) os recomiendo el uso de librerías como Altair, Plotly o Bokeh. Esta recomendación viene motivada por el hecho de que Matplotlib, del mismo modo que permite interactuar con las figuras en Spyder sin ningún problema, en Google Colab presenta un comportamiento diferente.

En este sentido, en caso de que sea de vuestro interés, podéis explorar el siguiente cuaderno de Colab, en donde se muestran distintas técnicas y librerías de visualización: https://colab.research.google.com/notebooks/charts.ipynb
"""